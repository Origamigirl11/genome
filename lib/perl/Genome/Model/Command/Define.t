#!/usr/bin/env genome-perl

use strict;
use warnings;

use above "Genome";
use Genome::Test::Factory::Sample;
use Genome::Test::Factory::ProcessingProfile::ReferenceAlignment;
use Genome::Test::Factory::Model::ReferenceSequence;
use Test::More;
plan tests => 34;

$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;

my $subject = Genome::Test::Factory::Sample->setup_object;
my $processing_profile = Genome::Test::Factory::ProcessingProfile::ReferenceAlignment->setup_object;
my $refseq = Genome::Test::Factory::Model::ReferenceSequence->setup_reference_sequence_build;

# test create for a genome model with defined model_name
successful_create_model({
        model_name               => "test_model_1",
        subject_name             => $subject->name,
        processing_profile       => $processing_profile,
        reference_sequence_build => $refseq->id,
    });

my $group1 = Genome::ModelGroup->create(name => "test 1");
my $group2 = Genome::ModelGroup->create(name => "test 2");
test_model_from_params_with_group($group1, $group2);

done_testing();


########################################################3

my $cnt = 0;
sub test_model_from_params_with_group {
    my (@groups) = @_;

    # test normal model and processing profile creation for reference alignment with a model group addition
    successful_create_model({
            model_name               => "test_model_incomplete_data_dir_" . Genome::Sys->username,
            subject_name             => $subject->name,
            processing_profile       => $processing_profile,
            reference_sequence_build => $refseq->id,
            groups => \@groups,
        });
}

sub successful_create_model {
    my $params = shift;
    my %params = %{$params};

    if (!$params{subject_name}) {
        $params{subject_name} = 'invalid_subject_name';
    }
    my $expected_user_name = Genome::Sys->username;
    my $current_time = UR::Context->current->now;
    my ($expected_date) = split('\w',$current_time);
  
    my $create_command = Genome::Model::Command::Define::ReferenceAlignment->create(%params);
    isa_ok($create_command,'Genome::Model::Command::Define::Helper');

    $create_command->dump_error_messages(0);
    $create_command->dump_warning_messages(0);
    $create_command->dump_status_messages(0);
    $create_command->queue_error_messages(1);
    $create_command->queue_warning_messages(1);
    $create_command->queue_status_messages(1);

    ok($create_command->execute, 'create command execution successful');
    my @error_messages = $create_command->error_messages();
    print @error_messages, "\n";
    my @warning_messages = $create_command->warning_messages();
    my @status_messages = $create_command->status_messages();
    ok(! scalar(@error_messages), 'no error messages');
    if ($params{'model_name'}) {
        SKIP: {
            skip '_build_model_filesystem paths got moved into Genome::Model', 2 unless (0);
            ok(scalar(@warning_messages), 'create model generated a warning message');
        like($warning_messages[0], qr(model symlink.*already exists), 'Warning message complains about the model link already existing');
        }
    } else {
        ok(!scalar(grep { not m/already exists/ } @warning_messages), 'no warning messages');
        if (@warning_messages) {
            print join("\n",@warning_messages);
        }
    }
    ok(scalar(@status_messages), 'There was a status message');

    my @create_status_messages = grep { /Created model:/ } @status_messages;
    ok(@create_status_messages, 'Got create status message');
    # FIXME - some of those have a second message about creating a directory
    # should probably test for that too
    delete($params{bare_args});
    delete($params{model_name});
    delete($params{reference_sequence_build}); #This property will be the build, not the name/ID
    my $model_id = $create_command->result_model_id;
    ok($model_id, 'got created model id') or die;
    my $model = Genome::Model->get($model_id,);
    ok($model, 'creation worked for '. $model->name .' model');
    for my $property_name (keys %params) {
        # Don't test this one, since it comes in as a string and gets split. They will not be equal
        next if ($property_name eq "groups");
        is($model->$property_name,$params{$property_name},$property_name .' model indirect accessor');
    }
    is($model->run_as,$expected_user_name,'model run_as accesssor');
    is($model->created_by,$expected_user_name,'model created_by accesssor');
    ok($model->creation_date, 'model creation_date accessor');
    is($model->processing_profile,$processing_profile,'model processing_profile_id indirect accessor');
    is($model->type_name,$processing_profile->type_name,'model type_name indirect accessor');


    # test that model group membership is as expected
    SKIP: {
        skip 'only test group membership if one is expected', 1 unless $params{groups};
        my @groups_expected = @{$params{groups}};
        my @groups_actual = $model->model_groups;
        is(scalar(@groups_actual), scalar(@groups_expected), "Model is a member of the correct number of groups");
    }

}

1;

